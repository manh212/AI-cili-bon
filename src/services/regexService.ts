
import type { RegexScript } from '../types';

/**
 * Creates a RegExp object from a string, supporting both simple strings
 * and the "/pattern/flags" format common in SillyTavern.
 * @param regexString The string to parse.
 * @returns A RegExp object.
 * @throws {Error} if the pattern is invalid.
 */
const createRegex = (regexString: string): RegExp => {
    const match = regexString.match(new RegExp('^/(.*?)/([gimsuy]*)$'));
    if (match) {
        return new RegExp(match[1], match[2]);
    } else {
        return new RegExp(regexString, 'g');
    }
};

/**
 * MASKING UTILITIES
 */
const MASK_TOKEN_PREFIX = '___ST_PROTECTED_BLOCK_';
const MASK_TOKEN_SUFFIX = '___';

interface MaskResult {
    maskedText: string;
    artifacts: string[]; // Stores the raw original blocks (including fences)
}

/**
 * Scans text for sensitive code blocks and replaces them with tokens.
 * This protects code from being corrupted by user regex scripts.
 */
const maskSensitiveContent = (text: string): MaskResult => {
    const artifacts: string[] = [];
    let maskedText = text;

    const replaceAndStore = (regex: RegExp) => {
        maskedText = maskedText.replace(regex, (match) => {
            const index = artifacts.length;
            artifacts.push(match);
            return `${MASK_TOKEN_PREFIX}${index}${MASK_TOKEN_SUFFIX}`;
        });
    };

    // 1. Fenced Code Blocks (```...```) - Most common for LLM output
    replaceAndStore(/```[\s\S]*?```/g);

    // 2. Script Tags (<script>...</script>)
    replaceAndStore(/<script[^>]*>[\s\S]*?<\/script>/gi);

    // 3. Style Tags (<style>...</style>)
    replaceAndStore(/<style[^>]*>[\s\S]*?<\/style>/gi);

    // 4. Full HTML Documents (<!DOCTYPE...html...>)
    replaceAndStore(/(?:<!DOCTYPE html>)?\s*<html[^>]*>[\s\S]*?<\/html>/gi);

    return { maskedText, artifacts };
};

/**
 * Extracts inner content from a raw artifact for Iframe usage.
 * e.g., strips markdown fences from ```html ... ```
 */
const unwrapArtifact = (rawArtifact: string): string => {
    // Check for fenced code blocks
    const fencedMatch = rawArtifact.match(/^```(?:text|html|xml|javascript|js|css)?\s*([\s\S]*?)\s*```$/i);
    if (fencedMatch && fencedMatch[1]) {
        return fencedMatch[1].trim();
    }
    // Return raw if it's just a script tag or html block
    return rawArtifact.trim();
};

/**
 * Extracts potential interactive blocks from text (Legacy/Fallback logic).
 * Used to find *new* blocks generated by regex scripts themselves.
 */
const extractInteractiveContent = (text: string): string[] => {
    const blocks: string[] = [];
    
    // 1. Capture Fenced Blocks
    const fencedRegex = /```(?:text|html|xml|javascript)?\s*([\s\S]*?)\s*```/gi;
    let match;
    while ((match = fencedRegex.exec(text)) !== null) {
        const content = match[1].trim();
        if (content && (content.includes('<div') || content.includes('<script') || content.includes('<style') || content.includes('<details') || content.includes('<!DOCTYPE'))) {
             blocks.push(content);
        }
    }

    // 2. Capture Raw HTML/Script Blocks
    const rawHtmlRegex = /(?:<!DOCTYPE html>)?\s*<html[^>]*>[\s\S]*?<\/html>/gi;
    while ((match = rawHtmlRegex.exec(text)) !== null) blocks.push(match[0].trim());
    
    const scriptRegex = /<script[^>]*>[\s\S]*?<\/script>/gi;
    while ((match = scriptRegex.exec(text)) !== null) {
        if (!blocks.some(b => b.includes(match![0]))) blocks.push(match[0].trim());
    }

    return blocks;
};


/**
 * THE PIPELINE PROCESSOR (Updated: Masking & Protection Strategy)
 * 
 * Pipeline:
 * 1. Mask: Hide sensitive code blocks (artifacts) from the raw text.
 * 2. Process: Run user Regex scripts on the masked text.
 * 3. Unmask (Display): Remove tokens from the text for UI display.
 * 4. Unmask (Logic): Recover original artifacts for the Iframe.
 * 
 * @param rawText The text to process
 * @param scripts The list of regex scripts
 * @param targetPlacement Array of placement IDs. Default [2] (Output).
 */
export const processWithRegex = (
    rawText: string, 
    scripts: RegexScript[] = [],
    targetPlacement: number[] = [2] 
): { displayContent: string; interactiveHtml: string | null; diagnosticLog: string; } => {
    
    const diagnosticLog: string[] = [`[START] Regex Pipeline (Target: ${targetPlacement.join(',')}). Strategy: Masking.`];
    
    // --- STEP 1: MASKING (Tạo mặt nạ bảo vệ) ---
    // Only apply masking for Output (2) or Input (1) if strict protection is needed.
    // For now, we apply it generally to be safe.
    const { maskedText, artifacts } = maskSensitiveContent(rawText);
    let processedText = maskedText;

    if (artifacts.length > 0) {
        diagnosticLog.push(`[MASK] Protected ${artifacts.length} code blocks from regex modification.`);
    }

    // --- STEP 2: PROCESSING (Chạy Regex trên văn bản đã che) ---
    const validScripts = (scripts || []).filter((script) => {
        if (script.disabled) return false;
        const scriptPlacement = (script.placement && script.placement.length > 0) ? script.placement : [2];
        return targetPlacement.some(p => scriptPlacement.includes(p)) && !!script.findRegex;
    });

    const sortedScripts = [...validScripts].sort((a, b) => {
        // Generators first, Removers last
        const aGen = a.replaceString.includes('```') || a.replaceString.includes('<div');
        const bGen = b.replaceString.includes('```') || b.replaceString.includes('<div');
        if (aGen && !bGen) return -1;
        if (!aGen && bGen) return 1;
        return 0;
    });

    if (sortedScripts.length > 0) {
        sortedScripts.forEach((script) => {
            try {
                const regex = createRegex(script.findRegex);
                const textBefore = processedText;
                processedText = textBefore.replace(regex, script.replaceString);
                
                if (textBefore !== processedText) {
                     diagnosticLog.push(` -> [OK] Script "${script.scriptName}" applied.`);
                }
            } catch (error) {
                diagnosticLog.push(` -> [ERR] Script "${script.scriptName}": ${error instanceof Error ? error.message : String(error)}`);
            }
        });
    }

    // --- STEP 3: UNMASKING & EXTRACTION (Gỡ mặt nạ & Trích xuất) ---
    const isOutputMode = targetPlacement.includes(2);
    let finalInteractiveHtml: string | null = null;
    let displayContent = processedText;

    if (isOutputMode) {
        // A. Logic Extraction (Iframe)
        // 1. Recover protected artifacts (High Priority)
        const protectedBlocks = artifacts.map(unwrapArtifact);
        
        // 2. Detect *new* blocks generated by Regex (e.g., status bars added by scripts)
        // These are NOT masked, so they are visible in 'processedText'.
        const generatedBlocks = extractInteractiveContent(processedText);
        
        // Combine: Original Protected + Regex Generated
        const combinedBlocks = [...protectedBlocks, ...generatedBlocks];
        
        // Deduplicate simple overlaps
        const uniqueBlocks = Array.from(new Set(combinedBlocks));
        
        if (uniqueBlocks.length > 0) {
            finalInteractiveHtml = uniqueBlocks.join('\n');
            diagnosticLog.push(`[EXTRACT] Prepared ${uniqueBlocks.length} interactive blocks for Iframe.`);
        }

        // B. Display Cleanup (Chat UI)
        // 1. Remove Mask Tokens (They represent code we don't want to show as raw text)
        // We replace them with empty string because the code logic is handled by Iframe/State.
        // Unless it's a specific placeholder, we usually hide code in chat.
        displayContent = displayContent.replace(new RegExp(`${MASK_TOKEN_PREFIX}\\d+${MASK_TOKEN_SUFFIX}`, 'g'), '');
        
        // 2. Remove any remaining technical blocks (Generated by regex or missed)
        displayContent = displayContent.replace(/```(?:text|html|xml|javascript)?\s*([\s\S]*?)\s*```/gi, '');
        
        // 3. Clean ST specific tags
        displayContent = displayContent
            .replace(/<\/?(maintext|opening|StatusPlaceHolderImpl|Status_?block)>[\s\S]*?<\/?(maintext|opening|StatusPlaceHolderImpl|Status_?block)>/gi, '') 
            .replace(/<\/?(maintext|opening|StatusPlaceHolderImpl|Status_?block)\/?>/gi, '')
            .trim();
    } else {
        // For Input mode (1), we usually just want the text with tokens restored to original if needed,
        // or just stripped. Usually Regex on Input is for formatting text sent TO the LLM.
        // If we masked something in Input, we probably want to put it back?
        // Actually, Input regex usually modifies *user text*. User rarely types code blocks.
        // If they do, we restore them so they go to LLM intact.
        
        displayContent = displayContent.replace(new RegExp(`${MASK_TOKEN_PREFIX}(\\d+)${MASK_TOKEN_SUFFIX}`, 'g'), (_, index) => {
            return artifacts[parseInt(index, 10)] || '';
        });
    }

    return { 
        displayContent, 
        interactiveHtml: finalInteractiveHtml, 
        diagnosticLog: diagnosticLog.join('\n') 
    };
};
